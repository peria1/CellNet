# -*- coding: utf-8 -*-
"""
dldb.py

Defines a class to represent an lmdb database containing image data of 
appropriate dimensions, and all necessary metadata, for deep learning.


Created on Wed Apr 25 05:52:46 2018

@author: Bill Peria
"""
import openslide
import numpy as np
#import scipy as sp
import skimage.transform
import glob
import lmdb
import pickle
import os
#import sys
import matplotlib.pyplot as plt
import platform as platf
import time
import imageio
import pandas as pd
import tkinter as tk
import gc

class DLDB:
    def __init__(self, input_directory = None, visualize = False,
                  append_to=None, supervised=False,
                  tileSize=[299,299],use_level=2,
                  build = False, caffe_name = None, test_frac = 0.17,
                  use_metadata = False, file_type = 'svs',RBMD = None,
                  sheet_name = None):
                
        metadata_loaded = False
        
        if RBMD == None:
            RBMD = '/media/bill/Windows/Users/peria/Desktop/work/writingProjects/CellNet/NN Image metadata 20180710 WJP.xlsx'
            sheet_name='Merged Master Inventory'
        
        ffs = use_level

        if not caffe_name == None:
            try:
                os.mkdir(caffe_name)
            except:
                print('Unable to create ' + caffe_name +'. Does it exist already?')
                return None
                    
        if build:
            map_size = 1e12 # does this reserve a terabyte of disk? 
            dbname = 'DLDB_' + self.date_for_filename()
           # global currentFile
           
            if input_directory==None:
                input_directory =self.uichoosedir()
                
            dx,dy = tileSize 
            
            #
            #  Each of our directories needs to contain a file listing of 
            #   polygons enclosing tissue segments; the file needs to be called segments.dat
            #
            #  The vertices are obtained by mouse clicks recorded by WSIseg()
            #
            with open(input_directory + self.get_slash() + 
                      'segments.dat','rb') as file:
                segs = pickle.loads(file.read())

            newSourceImages = sorted(glob.glob(input_directory + self.get_slash() + '*.' + file_type))

            env = lmdb.open(dbname, map_size = map_size, writemap=True)
            with env.begin(write=True) as txn:
                tileCount = 0
                # need to record header here. Creation date, path to files, number of files, metadata header, etc.
                txn.put('number_of_source_files'.encode(),pickle.dumps(len(newSourceImages)))
                for currentFile in newSourceImages:
                    print('Processing ' + self.just_filename(currentFile))
                    try:
                        I = openslide.open_slide(currentFile) # read in current file
                     #   level_downs = I.level_downsamples 
        
#                    if  (use_level >= len(level_downs)):
#                        print('Level exceeds number of dimensions...quitting.')
#                        break
#                    else:
                      #  ts = self.TissueSeg(currentFile)
                      
                        polygons = segs[self.just_filename(currentFile)]
                        
                        tiles_to_start = tileCount
                        tileCount = self.makeTiles(I, txn, env, dx, dy, currentFile, polygons, tileCount,\
                                       use_level = ffs, visualize = visualize)
                        
                        if tileCount > tiles_to_start:
                            if use_metadata:
#------------------
# Here I need to handle the cases where there is more than one species on a slide.
# Basic plan is to look at species field and comma-separate it. If there is more than
# one entry, I need to hand segment the by specifiying polygons enclosing each piece. 
# So there's one polygon per species or tissue type, and therefore I can pair the right
# species with each tile. THis means also that "UniqueID" is no longer good enough
# to determine the full metadata dictionary of the tile. I guess maybe there just needs
# to be a get_species and get_tissue methods, and these access the UniqueID'd 
# dictionary and pick the right species. The tile will need a segment number or 
# polygon number generated by using the tile origin and the file dict's polygon list. 
#
# Ok, it's different from that a bit: I need to re-write the metadata so that by 
# the time one gets to this point in DLDB, the polygon list is already available. 
# So I should probably write another function that fixes the metadata. The following 
# writes a dataframe to Excel. 
#
#  writer = pd.ExcelWriter('output.xlsx')
#  df1.to_excel(writer,'Sheet1')
#  df2.to_excel(writer,'Sheet2')
#  writer.save()
# Then I need to learn to append a column to a dataframe. 
#------------------
                                if metadata_loaded == False:
                                    md = pd.read_excel(RBMD,sheet_name = sheet_name, 
                                                       dtype=str,converters = {'Magnification': int})
                                    metadata_loaded = True
                                    tags = md.UniqueID
                            
                                this_row = md.loc[tags + '.' + file_type == self.just_filename(currentFile)]
                                stuff = {"number_of_tiles":tileCount}
                                if not this_row.empty:
                                    for col in this_row.columns:
                                        stuff.update({col:this_row[col].values[0]})
                            
                                stuff.update(dict(I.properties)) # just slam the whole Aperio dictionary in there
                            
                                self.record_metadata(txn,currentFile,stuff)

#                            for tile in tiles:   # TODO
#                                txn.put(str(tileCount).encode(), pickle.dumps(tile))
#                                tileCount += 1  
                    except BaseException as e:
                        print(self.just_filename(currentFile) + ' failed...')
                        print(e)
                    txn.put('number_of_tiles'.encode(),pickle.dumps(tileCount))  # TODO
                
            env.close()
            dbdir = dbname
        else:
            if input_directory == None:
                dbdir = self.uichoosedir()
            else:
                dbdir = input_directory
                
        global envr
        envr = lmdb.open(dbdir)
        self.env = envr
        
        if not caffe_name == None:
            print(caffe_name)
            self.feed_caffe(caffe_name, test_frac)  
            
            
    def makeTiles(self, I, txn, env, dx, dy, currentFile, polygons, tileCount,\
                  use_level=None, visualize=False):
        
        TISSUE_BOX = 'g-'
        EMPTY_BOX = 'r-'
        
        ul_corners = []
        ultry_corners = []
        npoly = len(polygons)

        xsq = np.array([0,1,1,0,0])
        ysq = np.array([0,0,1,1,0])
        
        level_dims = I.level_dimensions 
        level_downs = I.level_downsamples 
                
        ymax = int(level_dims[use_level][1]*level_downs[use_level])
        xmax = int(level_dims[use_level][0]*level_downs[use_level])
        dxscoot = int(dx * level_downs[use_level])
        dyscoot = int(dy * level_downs[use_level])
                            
        J_whole = np.asarray(I.read_region((0,0),len(level_dims)-1,level_dims[-1]))   
#
#   These are the arguments to read_region:         
#        location (tuple) – (x, y) tuple giving the top left pixel in the 
#               level 0 reference frame
#        level (int) – the level number
#        size (tuple) – (width, height) tuple giving the region size in the current 
#           level frame. So, if level_use is not zero, the location tuple might have
#           larger numbers than the size tuple. 
#
        for y0 in range(0,ymax-dyscoot,dyscoot):
            for x0 in range(0,xmax-dxscoot,dxscoot):
                for sn,pg in enumerate(polygons):
                    if in_poly((x0+int(dx/2),y0+int(dy/2)),pg):
                        ultry_corners.append((x0,y0,sn))
        
        print(len(ultry_corners))
        
        block = int(len(ultry_corners)/10)
        if block == 0:
            block = 1
        
        for corner in ultry_corners:
         #   gc.collect()
 #           print('corner: ',corner[0:2],'use_level: ',use_level,'size: ',(dx,dy))
            J = np.asarray(I.read_region(corner[0:2],use_level,(dx,dy)))
            J_resize = skimage.transform.resize(J,(dx,dy),mode='constant')
#            plt.imshow(J_resize)
#            plt.pause(0.2)
            
            box_style = EMPTY_BOX
            if self.tile_has_tissue(J_resize):
                tile = self.dlTile(J_resize,corner,currentFile)
                txn.put(str(tileCount).encode(), pickle.dumps(tile))
            #    print(txn.stat())
#                txn.commit()
#                txn.stat()

                if tileCount % block == 0:
                    print(str(tileCount) + '/' + str(len(ultry_corners))+" at " + self.time_of_day())
                tileCount +=1
                ul_corners.append(corner)
                box_style = TISSUE_BOX
#                if count == 0:
#                    tiles = [self.dlTile(J_resize,corner,currentFile)] * len(ultry_corners)
#                    ul_corners = [corner] * len(ultry_corners)
#                else:
#                    # I think this is the "memory leak"
#                    #tiles.append(self.dlTile(J_resize,corner,currentFile))
#                    tiles[count] = self.dlTile(J_resize,corner,currentFile)
#                    
            
            if visualize:
                plt.figure(1)
                plt.clf()
                plt.imshow(J_whole)
                
                xdraw = (corner[0] + xsq*dxscoot)/level_downs[-1]
                ydraw = (corner[1] + ysq*dyscoot)/level_downs[-1]
                
                plt.plot(xdraw,ydraw,box_style)
                plt.pause(0.05)
                plt.figure(2)
                plt.clf()
                plt.imshow(J_resize)
                plt.pause(0.01)
            
        print(tileCount)
        return tileCount
#        plt.figure(1)
#        plt.clf()
#        plt.imshow(J_whole)
#        box_style = TISSUE_BOX
#        for corner in ul_corners:
#            x0, y0 = corner[0:2]
#            xdraw = (x0 + xsq*dxscoot)/level_downs[-1]
#            ydraw = (y0 + ysq*dyscoot)/level_downs[-1]
#            plt.plot(xdraw,ydraw,box_style) 
#        tiles = tiles[0:count+1] 
#        ul_corners = ul_corners[0:count+1]

            
    def record_metadata(self,txn,currentFile,stuff):
        txn.put(currentFile.encode(), pickle.dumps(stuff))
        
    def feed_caffe(self, caffe_name, test_frac):     
        
        label = '0'   # YIKES!!! No classification labels! 
        
        train_txt  = caffe_name + self.get_slash() + 'train.txt'
        test_txt = caffe_name + self.get_slash() + 'test.txt'
        
        with self.env.begin() as txn:
            with txn.cursor() as curs:
                if curs.first():
                   while True:
                       tile = pickle.loads(txn.get(curs.key()))
                       (x0,y0)=tile.origin
                       last_dot = tile.sourcefile.rfind('.')
                       last_slash = tile.sourcefile.rfind(self.get_slash())
                       filename = tile.sourcefile[last_slash:last_dot] + \
                       '_' + str(x0) + '_' + str(y0) + '.jpg'
                       
                       full_path = caffe_name + filename
                       #sp.misc.imsave(full_path, tile.data[:,:,0:3])
                       imageio.imwrite(full_path, tile.data[:,:,0:3])
                       
                       text_entry = full_path + '   ' + label + '\n' # all labels zero for now
                       
                       if (np.random.uniform() > test_frac):
                          with open(train_txt,'a') as f:
                              f.write(text_entry)
                       else:
                          with open(test_txt,'a') as f:
                              f.write(text_entry)

                       
                       if not curs.next():
                           break
                else:
                    print('Something is very wrong...first key is bad...can''t even start...')
            
            
    def stat(self):
        return self.env.stat()
    
        
    def get_random_tile(self):  
        with envr.begin(write=False) as txn:
#            keypick = str(int(np.floor(
#                    np.random.uniform(low=0,high=envr.stat()['entries'])))).encode()
            num_tiles_str = 'number_of_tiles'.encode()
            keypick = str(int(np.floor(
                    np.random.uniform(low=0,high=pickle.loads(txn.get(num_tiles_str)))))).encode()
#            keypick = str(int(np.floor(
#                    np.random.uniform(low=0,high=100)))).encode()
#            print(keypick
            return pickle.loads(txn.get(keypick))
#        if append_to != None:
#            self.sourceCatalog = append_to.sourceCatalog.append(sourceCatalog)
#            self.dataArray = append_to.dataArray.append(dataArray)
#        else:
#            self.sourceCatalog = sourceCatalog
#            self.dataArray = dataArray
#        self.sourceCatalog = sourceCatalog
#        self.dataArray = dataArray
    def get_minibatch(self,N):
        mbt = self.get_random_tile()
        (nx, ny, nalpha) = mbt.data.shape
        batch = np.zeros((N,nx,ny,nalpha))
        for i in range(N):
            batch[i,:,:,:] = self.get_random_tile().data
        return batch
            
    
    def tile_has_tissue(self, J): # this works for H & E only!!!
        white = np.min(J,axis=2)>0.92
      #  plt.imshow(np.min(J,axis=2))
        return np.mean(white) < 0.9
# compute mean pixel value to ignore non-tissue        
#        return J[:,:,0:2].mean() < 224  # Laura's starting criterion
    
    def uichoosedir(self): # not even kidding
        from tkinter.filedialog import FileDialog
        root = tk.Tk()
        root.focus_force()
        root.withdraw() # we don't want a full GUI, so keep the root window 
                        #  from appearing
        pathname = tk.filedialog.askdirectory()
        return pathname
    
    def DLDBchoosefile(self):
        import tkinter as tk
        from tkinter.filedialog import FileDialog
        root = tk.Tk()
        root.withdraw() # we don't want a full GUI, so keep the root window from appearing
        filename = tk.filedialog.askopenfilename()
        return filename

    def get_slash(self):
        if platf.system() == 'Windows':
            slash = '\\' # So pythonic!! Duplicit is better than complicit. 
        else:
            slash = '/'
        return slash
    
    def date_for_filename(self):
        tgt = time.localtime()
        year = str(tgt.tm_year)
        mon = "{:02}".format(tgt.tm_mon)
        day = "{:02}".format(tgt.tm_mday)
        hour = "{:02}".format(tgt.tm_hour)
        minute = "{:02}".format(tgt.tm_min)
        datestr = year + mon + day + '_' + hour + minute
        return datestr

    def time_of_day(self):
        tgt = time.localtime()
        hour = "{:02}".format(tgt.tm_hour)
        minute = "{:02}".format(tgt.tm_min)
        timestr = hour + ':' + minute
        return timestr
        
    def just_filename(self, path):
        return path.split(sep=self.get_slash())[-1]
        
    
    class dlTile(): 
        # A tile is a numpy image of the right shape, with the source file name
        # and upper-left-corner coordinates attached
        def __init__(self,img,corner,currentFile):
            dx, dy = np.array(img[:,:,0]).shape
            self.data = img
            self.origin = (corner[0],corner[1])
            self.segment = corner[2]
            self.sourcefile = currentFile
            
        def show(self):
#            plt.close()
#            plt.figure()
#            plt.clf()
            plt.imshow(self.data)
    #            plt.title(DLDB.just_filename(DLDB,self.sourcefile)+ ': ' + str(self.origin))\
    #   Why can't I just use the DLDB function just_filename?!! dlTile is a subclass
    #     of DLDB!!! I hate python
            plt.title(self.sourcefile.split(sep='/')[-1] + ': ' + str(self.origin))
        #    plt.title(DLDB.just_filename(self, self.sourcefile)+ ': ' + str(self.origin))
            plt.show()
           
        def get_metadata(self,key=None):
            with envr.begin(write=False) as txn:
                md = pickle.loads(txn.get(self.sourcefile.encode()))
            if key==None:
                return md
            elif key=='?':
                return([key for key in md.keys()])
            else:
                return(md[key])
            
    
        def show_metadata(self):
            md = self.get_metadata()
            for key in md.keys():
                print(key,': ',md[key])
    

#------------------------------------------------------------------------
                
#    import matplotlib.pyplot as plt
#    import numpy as np
#    import openslide
#    import DLDB as dl  # argh no that is not how this works. How do I import DLDB so that 
#                 # my hand segmenter is a subclass or child class of it? Is 
                 # subclass and child class the same thing? 
    
    
    # something like class TissueSeg(DLDB) goes here. The __init__ can basically be pulled 
    # from the __main__ bit below.
    
    class TissueSeg():
        
        def GPchoosefile(self):
            import tkinter as tk
            from tkinter.filedialog import FileDialog
            root = tk.Tk()
            root.withdraw() 
            filename = tk.filedialog.askopenfilename()
            return filename
 
        def onclick(self, event):
            if event.xdata == None:
                plt.pause(0.5)
                plt.close()
            
            if event.button == 3:
                self.xpoly.append(self.xpoly[0])
                self.ypoly.append(self.ypoly[0])
                plt.plot(self.xpoly,self.ypoly)
                self.fig.canvas.draw()
                this_poly = list(zip(np.rint(self.xpoly).astype(int),np.rint(self.ypoly).astype(int)))
                #print(this_poly)
                self.polygons.append(this_poly)
                self.xpoly[:] = []
                self.ypoly[:] = []        
                return
            else:
                self.xpoly.append(event.xdata)
                self.ypoly.append(event.ydata)
        
                if len(self.xpoly) > 1:
                    plt.plot(self.xpoly[-2:], self.ypoly[-2:])
                    self.fig.canvas.draw()
                else:
                    plt.plot(self.xpoly,self.ypoly,'o')
                    self.fig.canvas.draw()

        def __init__(self, imageFile = None):            
            plt.clf()
            if imageFile == None:
                imageFile = self.GPchoosefile()
                
            I = openslide.open_slide(imageFile)
            level_dims = I.level_dimensions 
                                    
            J_whole = np.asarray(I.read_region((0,0),len(level_dims)-1,level_dims[-1]))   
            plt.imshow(J_whole)
            plt.show()
            
            self.fig = plt.gcf()
            #ax = plt.gca()
        
            self.xpoly = []
            self.ypoly = []
            
            self.polygons = []
            
            self.file = imageFile
            
            self.cid = self.fig.canvas.mpl_connect('button_press_event', self.onclick)


#
# http://geomalgorithms.com/a03-_inclusion.html
#
# routine for performing the "point in polygon" inclusion test

# Copyright 2001, softSurfer (www.softsurfer.com)
# This code may be freely used and modified for any purpose
# providing that this copyright notice is included with it.
# SoftSurfer makes no warranty for this code, and cannot be held
# liable for any real or imagined damage resulting from its use.
# Users of this code must verify correctness for their application.

# translated to Python by Maciej Kalisiak <mac@dgp.toronto.edu>

#   a Point is represented as a tuple: (x,y)

#===================================================================

# is_left(): tests if a point is Left|On|Right of an infinite line.

#   Input: three points P0, P1, and P2
#   Return: >0 for P2 left of the line through P0 and P1
#           =0 for P2 on the line
#           <0 for P2 right of the line
#   See: the January 2001 Algorithm "Area of 2D and 3D Triangles and Polygons"

def is_left(P0, P1, P2):
    return (P1[0] - P0[0]) * (P2[1] - P0[1]) - (P2[0] - P0[0]) * (P1[1] - P0[1])

#===================================================================

#===================================================================

# wn_PnPoly(): winding number test for a point in a polygon
#     Input:  P = a point,
#             V[] = vertex points of a polygon
#     Return: wn = the winding number (=0 only if P is outside V[])

def wn_PnPoly(P, V):
    wn = 0   # the winding number counter

    # repeat the first vertex at end
#    V = tuple(V[:]) + (V[0],) # no, I already did so in WSIseg()

    # loop through all edges of the polygon
    for i in range(len(V)-1):     # edge from V[i] to V[i+1]
        if V[i][1] <= P[1]:        # start y <= P[1]
            if V[i+1][1] > P[1]:     # an upward crossing
                if is_left(V[i], V[i+1], P) > 0: # P left of edge
                    wn += 1           # have a valid up intersect
        else:                      # start y > P[1] (no test needed)
            if V[i+1][1] <= P[1]:    # a downward crossing
                if is_left(V[i], V[i+1], P) < 0: # P right of edge
                    wn -= 1           # have a valid down intersect
    return wn

def in_poly(P,V):
    return(wn_PnPoly(P,V) != 0)
